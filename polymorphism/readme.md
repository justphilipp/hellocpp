# 继承

## 1. 继承的本质和原理

### 1.1 本质

本质：代码复用；在基类中提供统一的虚函数接口，让不同的派生类重写（多态），即派生类和接口解耦。

类和类之间的关系：组合(a part of)，继承(a kind of)

### 1.2 继承的访问限定

| 继承方式  | 基类的访问限定                     | 派生类的访问限定                     | (main）外部的访问限定 |
| :-------: | ---------------------------------- | ------------------------------------ | --------------------- |
|  public   | public<br />protected<br />private | public<br />protected<br />不可见    | YES<br />NO<br />NO   |
| protected | public<br />protected<br />private | protected<br />protected<br />不可见 | NO<br />NO<br />NO    |
|  private  | public<br />protected<br />private | private<br />private<br />不可见     | NO<br />NO<br />NO    |

### 1.3 总结

1. 外部只能访问对象public成员，protected和private的成员无法直接访问
2. 在继承结构中，派生类从基类可以继承过来private成员，但是派生类无法直接访问
3. protected和private区别？这两种访问权限，类内都可以访问，类外均不可访问（友元除外）。区别在于继承时，protected权限下的数据成员可以被子类的成员函数访问，private则完全封闭了类外访问的所有权限，连子类也不能访问。

### 1.4 NOTE

基类的成员的访问限定，在派生类里是不可能超过继承方式的

protected成员只能被类成员函数、子类函数及友元访问，不能被其他任何访问，本身的类对象也不行

## 2. 派生类的构造过程

### 2.1 派生类对象构造与析构过程

1. 派生类调用基类的构造函数，初始化从基类继承来的成员
2. 调用派生类自己的构造函数，初始化派生类自己特有的成员
3. 派生类对象的作用域到期后，调用派生类的析构函数，释放派生类成员可能占用的外部资源（堆内存，文件）
4. 调用基类的析构函数，释放派生类内存中，从基类继承来的成员可能占用的外部资源（堆内存，文件）

### 2.2 NOTE

派生类从基类可以继承来所有的成员（变量和方法），除了构造函数和析构函数。

## 3. 重载、隐藏、覆盖

重载关系：一组函数要重载，必须处在同一个作用域当中，并且函数名字相同，参数列表不同。

隐藏（作用域的隐藏）关系：在继承结构当中，派生类的同名成员，把基类的同名成员隐藏掉。

覆盖关系：基类和派生类的方法，返回值、函数名以及参数列表都相同，且基类的方法是虚函数，那么派生类的方法就自动处理成虚函数，他们之间成为覆盖关系（虚函数表中，虚函数地址的覆盖）。

## 4. 类型转换

在继承结构中，默认只支持从下（派生类）到上（基类）的类型转换。

**NOTE** 如果将基类对象赋值给派生类对象，派生类对象自己的成员变量没有赋值；如果将派生类对象类型的指针指向基类对象，则会导致不安全的内存访问（派生类对象指针指向的内存空间更大）

## 5. 虚函数，静态绑定和动态绑定

### 5.1 虚函数表，虚函数指针和虚函数

**RTTI**(Run-time type information) :运行时的类型信息 

- [ ] 虚函数表介绍

如果一个类里面定义了虚函数，那么编译阶段，编译器需给这个类类型产生一个唯一的vftable（虚函数表）。虚函数表中主要存储的内容就是RTTI指针和虚函数的地址。当程序运行时，每一张虚函数表都会加载到内存的.rodata区（只读）。

一个类里面定义了虚函数，那么这个类定义的对象，其运行时，内存中多存储一个vfptr（虚函数指针），指向相应类型的虚函数表。一个类型定义的n个对象，它们的虚函数指针指向的是同一张虚函数表。

一个类里面虚函数的个数，不影响对象的内存大小（vfptr只有一个），影响的是虚函数表的大小。

如果派生类中的方法，和基类继承来的某个方法，返回值、函数名和参数列表都相同，且基类的方法是virtual函数，那么派生类的这个方法，自动处理成虚函数。

### 5.2 动态绑定和静态绑定

通过使用这些虚函数表，即使使用的是基类的指针来调用函数，也可以达到正确调用运行中实际对象的虚函数。 
我们把经过虚表调用虚函数的过程称为动态绑定，其表现出来的现象称为运行时多态。动态绑定区别于传统的函数调用，传统的函数调用我们称之为静态绑定，即函数的调用在编译阶段就可以确定下来了。

### 5.3 什么时候会执行函数的动态绑定

需要符合以下三个条件：

- 通过指针（或引用）来调用函数
- 指针upcast向上转型（派生类向基类的转换称为upcast）
- 调用的是虚函数

### 5.4 问题总结

#### 5.4.1 哪些函数不能实现成虚函数？

虚函数需要能产生地址，存储在vftable中；且对象必须存在（vfptr-> vftable ->虚函数地址）

1. 构造函数

构造函数中调用的任何函数(即使是虚函数)都是静态绑定的

2. static静态成员方法

static方法是属于类的，并不需要对象。

#### 5.4.2 虚析构函数

析构函数调用时，对象是存在的；

基类的析构函数如果是虚函数，那么派生类的析构函数自动成为虚函数。

什么时候把基类的析构函数实现成虚函数？ 基类的指针（引用）指向堆上new出来的派生类对象的时候。delete pb（基类的指针），它调用析构函数的时候，必须发生动态绑定，否则会导致派生类的析构函数无法调用。

# 多态

## 0 如何解释多态

静态（编译时期）的多态：函数重载、模板（函数模板和类模板）

动态（运行时期）的多态：在继承结构中，基类指针（引用）指向派生类对象，通过该指针（引用）调用同名覆盖方法（虚函数），基类指针指向哪个派生类对象，就会调用哪个派生类对象的覆盖方法，成为多态。

多态底层通过动态绑定实现，指针指向哪个对象，则访问其虚函数指针，通过该指针访问其虚函数表。从派生类对象虚函数表取出的，自然是对应的派生类对象的方法。

## 1. 抽象类和普通类

动物的基类，泛指，抽象一个实体的类型。

定义Animal的初衷，并不是让Animal抽象某个实体的类型，而是：

1. string _name，让所有的动物实体类通过继承Animal直接复用该属性
2. 给所有的派生类保留统一的覆盖/重写接口

拥有纯虚函数的类叫做抽象类，抽象类不能再实例化对象了，但是可以定义指针和引用变量。

一般把基类设计成抽象类。

