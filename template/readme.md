# C++模板

## 1. C++函数模板

模板的意义:对类型也可以进行参数化了

调用函数模板的过程：在函数调用点，编译器用用户指定的类型，从原模板实例化一份函数代码出来

函数模板：不进行编译，因为类型未知，无法编译

模板的实例化：在函数调用点进行实例化

模板函数：被编译器编译

模板类型参数：typename/class

模板非类型参数：必须是整数类型（整数或者地址/引动），都是常量，

模板的实参推演

模板的特例化（专用化）：特殊的实例化（不是编译器提供的，而是用户提供的）

函数模板、模板的特例化、非模板函数的重载关系：

模板代码不能在一个文件中定义，另一个文件中使用

模板代码调用之前，一定要看到模板定义的地方，这样的话，模板才能够进行正常的实例化，产生能够被编译器编译的代码。

所以一般模板代码都放在头文件中，然后在源文件中直接#include。

如果一定要分文件写，可以在模板定义的地方直接实例化：

`template bool compare<int>(int,int);`

## 2. 类模板

实现一个顺序容器vector；
实现空间配置器allocator；
实现迭代器iterator。

**为什么需要allocator：**
容器构造时，需要分开处理内存开辟和对象构造！
容器析构时，析构容器内有效的元素，然后释放_first指针指向的堆内存！
pop_back时，只需要析构对象。应把对象的析构和内存释放分离开！
allocator功能：内存开辟、内存释放、对象构造、对象析构

**迭代器通常实现成容器的嵌套类型**
vector底层为向量容器，所以提供[]操作符重载用于随机访问
